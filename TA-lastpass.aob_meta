{"basic_builder": {"appname": "TA-lastpass", "friendly_name": "LastPass", "version": "2.0.2", "author": "hcanivel", "description": "", "theme": "#D32D27", "large_icon": "iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAE3klEQVR4Xu2cf0xbVRTHv/e1pfze6BJmDRusZRQzWk00i9mYcaJRo5i5xGjUaYyZjjl1f8xMJfEPo24GE2d0srj4hy64OGJCZow/YjTGiZq4P2iZTukYTBRopFPoxmhfe819rITSvr5XShnwzvuH5L1zT+/93O85717ee4dB5fDVOVfFYNomgd3KGV8HMBsDzGr2i+k8B2SABxlnp2LgX0uIHnF3n/kz1RjYzJOd6ypsJazoJQBNYMhbTAOfdV85wgBax/iFlzecGghO95MAyFvrcMNiOc6Aqln/2CJuyIE+RCL3eE73+uLDmAIk4DCz5QcwlCziMWbfdY4xLkc2xiEpgERYFUtFJ42qnJlUhZJCsQvXi3BTAPnqXAfA8Gz2+JeQB4633N2/72bibgWY/YZJyHrnUEnccjXrqqt5UWLsVb3tjGQX47yZ+epc34Bhs5EGrnusHN8yr7tmmIGV625kIEMOHmBetyuyVFbIcz13YsXNfG4Xn2vHS8kfAdKYTQJEgLILeFIQKYgUlB0BUlB2/CgHkYJIQdkRIAUlEjCVlWH5XY0YO/E9wn1nNeEaLgetPnAQpbc0IPz3X/jjjgYCNJOAs70DBa5a5XS3Z/JvusNwCiJAGoogQARIK2ukvz4/CmIMlqvsYFYrIsND4OPjGfea5eXBYr8aPCojMjQEyHLGPqSCQphXrgSfmEBkaBDg2v8czSkgqbQU5U80YXnjFpjLypQBcVlG6OcfEWh9B+PeLs1BWh1OlD/1DEpuuhmS1arYR0Mh/Pfl5wi0vg05END0UeC5FuU7n0bx+hvBzJMvnMjBIP79tAOBw4cQGx1V9ZEzQHmrK1F16H3kVVSk/HEejWJw/ysIfnxUtXOlDbehYl8LpPz8lDby+fPo3/Ukxn1eVR+2Bx6EfW8zmMmU0iY8MIC+HY8jfK4/5fWcABKhVN3eAWvVmrSzyzlHf9N2hDpPJNnl17jgaDs2pRo1R0IJPVsbEQ2OJJkUb6xH5buHwVjSWzsJthNne+G/bwt4WLzVknjkBNCKRx6Dfc9eTekLg0tn/PDfe3eSrRhYSf0mXT5G2j7E4OuvJdlWd3yGfIdTl4/Bln0YOfLB/AByfNSOwjq3ro4JI6GACX/PlL2pdBlqv+tUDYuZjuWRf3B6c33CaevaGqz95LjuPlz0dqH34fvnB9A1P52EqbBId+fO7dmN0a++mLIvcHvgbDumu70w/LV+fUKyXXb7nVjV8qZuHyLx/7bhhnkC1PkLTMXFujtnOEAiuRa6PboBGS7EVmx7FPbnXtAF6JK/B/6tjcZK0mLVq9zm1zjSQsr5bb5+EyoPvrfwbvOCypwtFPe/oboW0rdQfAj255vBJCnlZF2RhWK8J8pWY/uOya2GzaacvjJbjetQvnPXwtpqJEzXtM2qPDyM2PhFXflputGS3KxmTGEBNsjJVmMBjnPWXSJAGugIEAGadXQpDUlBGvzowaEGIHr0nF0EJrU23JPVTPkRIA1iBIgAZRpUifakIFIQKSg7AqSg7PhRDiIFZakg+iRTHaDySSZ91JsOEA/QZ+HpIlB8Fk6FBdQJXS4sQKUpUiKKl6YQF6m4SQpE8eIm4hKVx0kElFQeR1ymAkuXIaUqsBTnRyW60pToikOiIm9pirxNj0QqEzhJ439eO8exTxMZGwAAAABJRU5ErkJggg==", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAACM0lEQVRYR+2YX0hTURzHv7+7DEeuOaLsuqJedIUu9SWiFJ966UGDiIJpTz30Migohn/DoeGbD0U+1FsWikRIJIgQISLWS+QQQl+EZkNFtqXDi2v3F3e40XWWV9q8J9h5uXB+h9/vc77nd+4550fYajPu8jNgaifiywAdBUApW46+DPAKM42DuPtcYO6rFicZ9EtF2TWJpAEQCnMU/O9uGYrKalPV7Pxr0pQhps+mwaRQGQoT19BMpWuACB5TlNkWlBkvKeAuXwLomAhAAC9TwO1S9yGBjc6XNSA2Ono/xuWBdlM5r5CwCh2/78PaxAfEPn3UMZq2ZK73kwgPD2K5/8l/DGQ5bEdifQ1QtX9nZpOsVjAzWFF2Tg1JgqXIhsSPaIZ9TwodunARzs4uHDxxEj8jESw97kN4eCjt1OJwwOl/BFtdPcCM6PgYvnd1QI3F0mMc12+gxHsPB4qLsRn8hkX/Q8Smp9J2w0AFcinKRkYhFepvIgt3bmN9ajLp8NTTZ7DV1ulmHXn3FsGWB8m+oku1ON3/XGdXlQ3MN15BPBRK9hsGOuK5BdnXmiFxeOQNFjtaYLHbcXZiGiD9/Y3jccyerwYSCTi7e+FouJrhI9Tbg9VXL/YK1AzZ1yYOUIEsby2ZVQdl2pJpFNlJ6pso8d7996T+XRZhtv1u50027IZ3WTaCGfEhHJBwh+ufVDTttM8DGUnsncYIuWSiPRQFe0oLV2wQrhyjZbpQBavU1hOlpPcL8XmGWLGN+/wAAAAASUVORK5CYII=", "visible": false, "tab_version": "3.0.1", "tab_build_no": "2", "build_no": 4}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "lastpass:users", "interval": "86400", "use_external_validation": true, "streaming_mode_xml": true, "name": "lastpass_users", "title": "LastPass Users", "description": "Collect snapshot of all users every 24h", "type": "customized", "parameters": [{"name": "lastpass_api_url", "label": "LastPass API URL", "help_string": "LastPass reporting REST API endpoint URL", "required": false, "format_type": "text", "default_value": "https://lastpass.com/enterpriseapi.php", "placeholder": "", "type": "text", "value": "https://lastpass.com/enterpriseapi.php"}], "data_inputs_options": [{"type": "customized_var", "name": "lastpass_api_url", "title": "LastPass API URL", "description": "LastPass reporting REST API endpoint URL", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "https://lastpass.com/enterpriseapi.php", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport json\nimport copy\nimport requests\nimport datetime\nimport traceback\n\nLP_CHECKPOINT_KEY = 'LastPass_user'\nCMD_REPORTING = 'getuserdata'\nPAGE_SIZE = 2000\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # lastpass_api_url = definition.parameters.get('lastpass_api_url', None)\n    # time_start = definition.parameters.get('time_start', None)\n    url = definition.parameters.get('lastpass_api_url', None)\n    try:\n        if 'https' in url:\n            return\n        # replace if http but not https\n        elif 'http' in url and 'https' not in url:\n            raise InputError('\"HTTP\" protocol not allowed. Enforcing HTTPS.')\n        elif '.' not in url:\n            raise InputError('URL submission invalid. Please validate domain.')\n    except Exception as e:\n        helper.log_error('{e.__class__.__name__}: LastPass http input definition failed: {e.message}')\n        return None\n\n\ndef save_checkpoint(helper, index):\n    ''' \n        update checkpoint with time value as epoch\n        @param index: page index for users\n        @type index: int\n    '''\n\n    try:\n        if isinstance(index, int):\n            helper.save_check_point(LP_CHECKPOINT_KEY, index)\n        else:\n            raise Exception(f'Invalid index key. Please validate value for index: {index}')\n    except Exception as e:\n        raise IOError(f'Save checkpoint failed. index=\"{index}\" reason=\"{e.message}\"')\n\n\ndef get_checkpoint(helper):\n    ''' \n        extract checkpoint index value\n        :return: index value or None\n    '''\n\n    # if checkpoint corrupted or not readable, consider empty\n    try:\n        index = helper.get_check_point(LP_CHECKPOINT_KEY)\n    except Exception as e:\n        helper.log_warning(f'Loading checkpoint. Unable to load checkpoint. reason=\"{e.message}\"') \n        return None\n\n    if str(index).isdigit():\n        return index\n\n    helper.log_warning(f'Loading checkpoint. Checkpoint time value not of int type. index=\"{index}\"')\n    return None\n\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_text = helper.get_arg('text')\n    opt_text_1 = helper.get_arg('text_1')\n    # In single instance mode, to get arguments of a particular input, use\n    opt_text = helper.get_arg('text', stanza_name)\n    opt_text_1 = helper.get_arg('text_1', stanza_name)\n\n    # get input type\n    helper.get_input_type()\n\n    # The following examples get input stanzas.\n    # get all detailed input stanzas\n    helper.get_input_stanza()\n    # get specific input stanza with stanza name\n    helper.get_input_stanza(stanza_name)\n    # get all stanza names\n    helper.get_input_stanza_names()\n\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    account = helper.get_user_credential_by_username(\"username\")\n    account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    global_cid = helper.get_global_setting(\"cid\")\n    global_provhash = helper.get_global_setting(\"provhash\")\n\n    # The following examples show usage of logging related helper functions.\n    # write to the log for this modular input using configured global log level or INFO as default\n    helper.log(\"log message\")\n    # write to the log using specified log level\n    helper.log_debug(\"log message\")\n    helper.log_info(\"log message\")\n    helper.log_warning(\"log message\")\n    helper.log_error(\"log message\")\n    helper.log_critical(\"log message\")\n    # set the log level for this modular input\n    # (log_level can be \"debug\", \"info\", \"warning\", \"error\" or \"critical\", case insensitive)\n    helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(url, method, parameters=None, payload=None,\n                                        headers=None, cookies=None, verify=True, cert=None,\n                                        timeout=None, use_proxy=True)\n    # get the response headers\n    r_headers = response.headers\n    # get the response body as text\n    r_text = response.text\n    # get response body as json. If the body text is not a json string, raise a ValueError\n    r_json = response.json()\n    # get response cookies\n    r_cookies = response.cookies\n    # get redirect history\n    historical_responses = response.history\n    # get response status code\n    r_status = response.status_code\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n    # The following examples show usage of check pointing related helper functions.\n    # save checkpoint\n    helper.save_check_point(key, state)\n    # delete checkpoint\n    helper.delete_check_point(key)\n    # get checkpoint\n    state = helper.get_check_point(key)\n\n    # To create a splunk event\n    helper.new_event(data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    \"\"\"\n\n    '''\n    # The following example writes a random number as an event. (Multi Instance Mode)\n    # Use this code template by default.\n    import random\n    data = str(random.randint(0,100))\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n    ew.write_event(event)\n    '''\n\n    '''\n    # The following example writes a random number as an event for each input config. (Single Instance Mode)\n    # For advanced users, if you want to create single instance mod input, please use this code template.\n    # Also, you need to uncomment use_single_instance_mode() above.\n    import random\n    input_type = helper.get_input_type()\n    for stanza_name in helper.get_input_stanza_names():\n        data = str(random.randint(0,100))\n        event = helper.new_event(source=input_type, index=helper.get_output_index(stanza_name), sourcetype=helper.get_sourcetype(stanza_name), data=data)\n        ew.write_event(event)\n    '''\n\n    rest_url = helper.get_arg('lastpass_api_url')\n\n    if not rest_url:\n        rest_url = 'https://lastpass.com/enterpriseapi.php'\n\n    helper.log_debug(f'LastPass parameter check: rest_url={rest_url}')\n    headers = { 'Content-Type': 'application/json' }\n\n    # build data params\n    data = {}\n    data['data'] = { 'pagesize': PAGE_SIZE }\n    data['cid'] = helper.get_global_setting('cid')\n    data['provhash'] = helper.get_global_setting('provhash')\n    data['cmd'] = CMD_REPORTING\n    data['apiuser'] = 'splunk.collector'\n\n    ''' algorithm w checkpointing:\n        if results are larger than max page size, checkpoint page index\n    '''\n    \n    time_val = datetime.datetime.now().timestamp()\n    try:\n        resp_ev = requests.post(rest_url, headers=headers, data=json.dumps(data))\n        \n        if resp_ev.status_code != 200:\n            helper.log_critical('LastPass report collection. request data failed.')\n            \n        resp_ev_json = resp_ev.json()\n\n        # track for malformed REST call\n        if resp_ev_json.get('status') and 'OK' not in resp_ev_json.get('status'):\n            helper.log_critical('Lastpass identity collection. REST call successful, but query is bad. Validate request params. Terminating script')\n            return\n            #sys.exit(1)\n\n    except Exception as e:\n        raise e                 \n\n    total = resp_ev_json.get('total')\n    count = resp_ev_json.get('count')\n\n    # track all identities\n    users = {}\n    groups = {}\n\n    try:\n        for user in resp_ev_json.get('Users'):\n            users[user] = copy.deepcopy(resp_ev_json.get('Users')[user])\n            users[user]['user_id'] = user\n            users[user]['time_collected'] = time_val\n            users[user]['event'] = 'list_users'\n\n            event = helper.new_event(data=json.dumps(users[user]),\n                                    time=time_val,\n                                    source=helper.get_input_type(),\n                                    index=helper.get_output_index(),\n                                    sourcetype=helper.get_sourcetype())\n            ew.write_event(event)\n\n        for group in resp_ev_json.get('Groups'):\n            groups[group] = {}\n            groups['members'] = copy.deepcopy(resp_ev_json.get('Groups')[group])\n            groups[group]['group_id'] = group\n            groups[group]['time_collected'] = time_val\n            groups[group]['event'] = 'list_groups'\n\n            # can only specify one sourcetype per input, hardcode for groups\n            event = helper.new_event(data=json.dumps(groups[group]),\n                                    time=time_val,\n                                    source=helper.get_input_type(),\n                                    index=helper.get_output_index(),\n                                    sourcetype='lastpass:groups')\n            ew.write_event(event)\n\n        # need to validate if need to paginate\n        chk_ptr = 0\n        if count < total:\n            chk_ptr = 0\n        \n            save_checkpoint(helper, event_time)\n            helper.log_debug(f'Updating checkpoint to index: {chk_ptr}')\n            \n            # TODO if users or groups > 2k, then need to update\n\n    except Exception as e:\n        helper.log_critical(f'Lastpass identity collection. Error in forwarding data: {traceback.format_exc()}')\n        raise e                 \n", "customized_options": [{"name": "lastpass_api_url", "value": "https://lastpass.com/enterpriseapi.php"}], "uuid": "dc8306a09c6a4131973bb4beb0b72714", "sample_count": "24"}, {"index": "default", "sourcetype": "lastpass:folders", "interval": "28800", "use_external_validation": true, "streaming_mode_xml": true, "name": "lastpass_shared_folders", "title": "LastPass Shared Folders", "description": "Collect snapshot of all shared folders every 8h", "type": "customized", "parameters": [{"name": "lastpass_api_url", "label": "LastPass API URL", "help_string": "LastPass reporting REST API endpoint URL", "required": false, "format_type": "text", "default_value": "https://lastpass.com/enterpriseapi.php", "placeholder": "", "type": "text", "value": "https://lastpass.com/enterpriseapi.php"}], "data_inputs_options": [{"type": "customized_var", "name": "lastpass_api_url", "title": "LastPass API URL", "description": "LastPass reporting REST API endpoint URL", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "https://lastpass.com/enterpriseapi.php", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport json\nimport copy\nimport requests\nimport datetime\nimport traceback\n\nLP_CHECKPOINT_KEY = 'LastPass_user'\nCMD_REPORTING = 'getsfdata'\nPAGE_SIZE = 2000\nUSER_EV_LIMIT = 50\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # lastpass_api_url = definition.parameters.get('lastpass_api_url', None)\n    # time_start = definition.parameters.get('time_start', None)\n    url = definition.parameters.get('lastpass_api_url', None)\n    try:\n        if 'https' in url:\n            return\n        # replace if http but not https\n        elif 'http' in url and 'https' not in url:\n            raise InputError('\"HTTP\" protocol not allowed. Enforcing HTTPS.')\n        elif '.' not in url:\n            raise InputError('URL submission invalid. Please validate domain.')\n    except Exception as e:\n        helper.log_error('{e.__class__.__name__}: LastPass http input definition failed: {e.message}')\n        return None\n\n\ndef save_checkpoint(helper, index):\n    ''' \n        update checkpoint with time value as epoch\n        @param index: page index for users\n        @type index: int\n    '''\n\n    try:\n        if isinstance(index, int):\n            helper.save_check_point(LP_CHECKPOINT_KEY, index)\n        else:\n            raise Exception(f'Invalid index key. Please validate value for index: {index}')\n    except Exception as e:\n        raise IOError(f'Save checkpoint failed. index=\"{index}\" reason=\"{e.message}\"')\n\n\ndef get_checkpoint(helper):\n    ''' \n        extract checkpoint index value\n        :return: index value or None\n    '''\n\n    # if checkpoint corrupted or not readable, consider empty\n    try:\n        index = helper.get_check_point(LP_CHECKPOINT_KEY)\n    except Exception as e:\n        helper.log_warning(f'Loading checkpoint. Unable to load checkpoint. reason=\"{e.message}\"') \n        return None\n\n    if str(index).isdigit():\n        return index\n\n    helper.log_warning(f'Loading checkpoint. Checkpoint time value not of int type. index=\"{index}\"')\n    return None\n\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_text = helper.get_arg('text')\n    opt_text_1 = helper.get_arg('text_1')\n    # In single instance mode, to get arguments of a particular input, use\n    opt_text = helper.get_arg('text', stanza_name)\n    opt_text_1 = helper.get_arg('text_1', stanza_name)\n\n    # get input type\n    helper.get_input_type()\n\n    # The following examples get input stanzas.\n    # get all detailed input stanzas\n    helper.get_input_stanza()\n    # get specific input stanza with stanza name\n    helper.get_input_stanza(stanza_name)\n    # get all stanza names\n    helper.get_input_stanza_names()\n\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    account = helper.get_user_credential_by_username(\"username\")\n    account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    global_cid = helper.get_global_setting(\"cid\")\n    global_provhash = helper.get_global_setting(\"provhash\")\n\n    # The following examples show usage of logging related helper functions.\n    # write to the log for this modular input using configured global log level or INFO as default\n    helper.log(\"log message\")\n    # write to the log using specified log level\n    helper.log_debug(\"log message\")\n    helper.log_info(\"log message\")\n    helper.log_warning(\"log message\")\n    helper.log_error(\"log message\")\n    helper.log_critical(\"log message\")\n    # set the log level for this modular input\n    # (log_level can be \"debug\", \"info\", \"warning\", \"error\" or \"critical\", case insensitive)\n    helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(url, method, parameters=None, payload=None,\n                                        headers=None, cookies=None, verify=True, cert=None,\n                                        timeout=None, use_proxy=True)\n    # get the response headers\n    r_headers = response.headers\n    # get the response body as text\n    r_text = response.text\n    # get response body as json. If the body text is not a json string, raise a ValueError\n    r_json = response.json()\n    # get response cookies\n    r_cookies = response.cookies\n    # get redirect history\n    historical_responses = response.history\n    # get response status code\n    r_status = response.status_code\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n    # The following examples show usage of check pointing related helper functions.\n    # save checkpoint\n    helper.save_check_point(key, state)\n    # delete checkpoint\n    helper.delete_check_point(key)\n    # get checkpoint\n    state = helper.get_check_point(key)\n\n    # To create a splunk event\n    helper.new_event(data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    \"\"\"\n\n    '''\n    # The following example writes a random number as an event. (Multi Instance Mode)\n    # Use this code template by default.\n    import random\n    data = str(random.randint(0,100))\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n    ew.write_event(event)\n    '''\n\n    '''\n    # The following example writes a random number as an event for each input config. (Single Instance Mode)\n    # For advanced users, if you want to create single instance mod input, please use this code template.\n    # Also, you need to uncomment use_single_instance_mode() above.\n    import random\n    input_type = helper.get_input_type()\n    for stanza_name in helper.get_input_stanza_names():\n        data = str(random.randint(0,100))\n        event = helper.new_event(source=input_type, index=helper.get_output_index(stanza_name), sourcetype=helper.get_sourcetype(stanza_name), data=data)\n        ew.write_event(event)\n    '''\n\n    rest_url = helper.get_arg('lastpass_api_url')\n\n    if not rest_url:\n        rest_url = 'https://lastpass.com/enterpriseapi.php'\n\n    helper.log_debug(f'LastPass parameter check: rest_url={rest_url}')\n    headers = { 'Content-Type': 'application/json' }\n\n    # build data params\n    data = {}\n    data['cid'] = helper.get_global_setting('cid')\n    data['provhash'] = helper.get_global_setting('provhash')\n    data['cmd'] = CMD_REPORTING\n    data['apiuser'] = 'splunk.collector'\n\n    ''' algorithm w checkpointing:\n        if results are larger than max page size, checkpoint page index\n    '''\n    \n    time_val = datetime.datetime.now().timestamp()\n    try:\n        resp_ev = requests.post(rest_url, headers=headers, data=json.dumps(data))\n        \n        if resp_ev.status_code != 200:\n            helper.log_critical('LastPass report collection. request data failed.')\n            \n        resp_ev_json = resp_ev.json()\n\n        # track for malformed REST call\n        if resp_ev_json.get('status') and 'OK' not in resp_ev_json.get('status'):\n            helper.log_critical('Lastpass identity collection. REST call successful, but query is bad. Validate request params. Terminating script')\n            return\n            #sys.exit(1)\n\n    except Exception as e:\n        raise e                 \n\n    # track all folders\n    folders = {}\n    user_count = 1\n    temp_folder = None\n\n    try:\n        for folder_id in resp_ev_json:\n            findex = 0\n            temp_folder = resp_ev_json[folder_id]\n            user_count = len(resp_ev_json[folder_id]['users'])\n\n            if user_count > USER_EV_LIMIT:\n                for ff in range(0, user_count, USER_EV_LIMIT):\n                    folder_idx = f'{folder_id}-{findex}'\n                    folders[folder_idx] = {}\n                    folders[folder_idx]['folder_id'] = folder_idx\n                    folders[folder_idx]['folder_index'] = findex\n                    folders[folder_idx]['time_collected'] = time_val\n                    folders[folder_idx]['event'] = 'list_folders'\n                    \n                    # copy all folder details into event entry,\n                    # for user, copy slice of user list\n                    for field in temp_folder.keys():\n                        if field == 'users':\n                            folders[folder_idx][field] = temp_folder[field][ff:(ff+USER_EV_LIMIT)]\n                        else:\n                            folders[folder_idx][field] = temp_folder[field]\n                    folders[folder_idx]['user_count'] = len(folders[folder_idx][field])\n\n                    event = helper.new_event(data=json.dumps(folders[folder_idx]),\n                                            time=time_val,\n                                            source=helper.get_input_type(),\n                                            index=helper.get_output_index(),\n                                            sourcetype=helper.get_sourcetype())\n                    ew.write_event(event)\n                    findex += 1\n            else:\n                folders[folder_id] = {}\n                folders[folder_id].update(temp_folder)\n                folders[folder_id]['folder_id'] = folder_id\n                folders[folder_id]['time_collected'] = time_val\n                folders[folder_id]['event'] = 'list_folders'\n                folders[folder_id]['user_count'] = len(folders[folder_id]['users'])\n\n                event = helper.new_event(data=json.dumps(folders[folder_id]),\n                                        time=time_val,\n                                        source=helper.get_input_type(),\n                                        index=helper.get_output_index(),\n                                        sourcetype=helper.get_sourcetype())\n                ew.write_event(event)                \n\n        # need to validate if need to paginate\n        chk_ptr = 0\n        '''\n        if count < total:\n            chk_ptr = 0\n        \n            save_checkpoint(helper, event_time)\n            helper.log_debug(f'Updating checkpoint to index: {chk_ptr}')\n            \n            # TODO need to validate limits on collecting shared folders\n        '''\n\n    except Exception as e:\n        helper.log_critical('Lastpass identity collection. Error in forwarding data: {traceback.format_exc()}')\n        raise e                 \n", "customized_options": [{"name": "lastpass_api_url", "value": "https://lastpass.com/enterpriseapi.php"}], "uuid": "5fe5060e1df447cc97074d498a59a466", "sample_count": "36"}, {"index": "default", "sourcetype": "lastpass:activity", "interval": "60", "use_external_validation": true, "streaming_mode_xml": true, "name": "lastpass_event_reporting", "title": "LastPass Event Reporting", "description": "Collect enterprise activity reporting events. All times should be represented in the local time zone of account. e.g., US/Pacific.", "type": "customized", "parameters": [{"name": "lastpass_api_url", "label": "LastPass API URL", "help_string": "LastPass reporting REST API endpoint URL", "required": false, "format_type": "text", "default_value": "https://lastpass.com/enterpriseapi.php", "placeholder": "", "type": "text", "value": "https://lastpass.com/enterpriseapi.php"}, {"name": "time_start", "label": "Collection Start Time", "help_string": "Supports two formats: epoch and YYYY-mm-dd HH:MM:SS. Supported timezone: PST. If there exists a time checkpoint, this value may be ignored.", "required": false, "format_type": "text", "default_value": "", "placeholder": "YYYY-mm-dd HH:MM:SS", "type": "text", "value": "2020-06-01 00:00:00"}], "data_inputs_options": [{"type": "customized_var", "name": "lastpass_api_url", "title": "LastPass API URL", "description": "LastPass reporting REST API endpoint URL", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "https://lastpass.com/enterpriseapi.php", "placeholder": ""}, {"type": "customized_var", "name": "time_start", "title": "Collection Start Time", "description": "Supports two formats: epoch and YYYY-mm-dd HH:MM:SS. Supported timezone: PST. If there exists a time checkpoint, this value may be ignored.", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": "YYYY-mm-dd HH:MM:SS"}], "code": "\n# encoding = utf-8\n\nimport re\nimport os\nimport sys\nimport time\nimport json\nimport copy\nimport requests\nimport datetime\nimport traceback\n\nLASTPASS_TIMEFORMAT = '%Y-%m-%d %H:%M:%S'  # PST\nLP_CHECKPOINT_KEY = 'LastPass_reporting'\nCMD_REPORTING = 'reporting'\nSTR_TSTART = 'time_start'\nSTR_TEND = 'time_end'\nSTR_TCURR = 'time_curr'\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # global_account = definition.parameters.get('global_account', None)\n    # lastpass_api_url = definition.parameters.get('lastpass_api_url', None)\n    # time_start = definition.parameters.get('time_start', None)\n    url = definition.parameters.get('lastpass_api_url', None)\n    if 'https://' in url:\n        return\n    # replace if http but not https\n    elif 'http' in url and 'https://' not in url:\n        helper.log_error(f'\"HTTP\" protocol not allowed. Please update for HTTPS.')\n        raise ValueError(f'\"HTTP\" protocol not allowed. Please update for HTTPS.')\n    elif '.' not in url:\n        helper.log_error(f'URL submission invalid. Please validate domain.')\n        raise ValueError(f'URL submission invalid. Please validate domain.')\n    elif 'https://' not in url:\n        # add proper url\n        definition.parameters['lastpass_api_url'] = 'https://'+url\n\n    time_start = definition.parameters.get(STR_TSTART, None)\n    try:\n        if str(time_start).isdigit():\n            time_dt = datetime.datetime.fromtimestamp(int(time_start))\n\n            diff = datetime.datetime.now() - time_dt\n            # check for within last 4y or if time is ahead\n            if diff.days > (365*4) or diff.days < 0:\n                helper.log_warning(f'Validating time format. out of range. time_val=\"{time_start}\"')\n                raise ValueError(f'Validating time format. out of range. time_val=\"{time_start}\"')\n        elif time_start == None: # if not specified, just reset in input definition\n            pass\n        else:\n            datetime.datetime.strptime(str(time_start), LASTPASS_TIMEFORMAT)\n    except Exception as e:\n        raise ValueError(f'{e.__class__.__name__}: LastPass http input configuration failed: {e}')\n        helper.log_error(f'{e.__class__.__name__}: LastPass http input configuration failed: {e}')\n        return None\n\n\ndef get_time_lp(time_val):\n    ''' return time value for date format suitable for lastpass API \n    @param time_val: epoch time or datetime object\n\n    :return: '%Y-%m-%d %H:%M:%S'  # PST\n    '''\n\n    if isinstance(time_val, datetime.datetime):\n        return time_val.strftime(LASTPASS_TIMEFORMAT)\n\n    return datetime.datetime.fromtimestamp(int(time_val)).strftime(LASTPASS_TIMEFORMAT)\n\n\ndef check_datetime(val):\n    '''\n        verify time value is a datetime object\n        @param val: time value\n        @type val: datetime or other\n    '''\n\n    try:\n        return isinstance(val, datetime.datetime)\n    except (TypeError, ValueError):\n        return False\n        \n\ndef check_digit(val):\n    '''\n        verify time value is a digit for epoch format\n        @param val: time value\n        @type val: int or other\n    '''\n\n    try:\n        check = int(val)\n        return True\n    except (TypeError, ValueError):\n        return False\n        \n\ndef check_float(val):\n    '''\n        verify time value is a float for epoch format\n        @param val: time value\n        @type val: float or other\n    '''\n\n    try:\n        return float(str(val)) > 0\n    except (TypeError, ValueError):\n        return False\n\n\ndef prepare_time_value(helper, val, field_name):\n    '''\n        prepare the time value for consistent epoch-friendly format\n        @param val: time value to be stored into checkpoint\n        @type val: some format for time\n        @param field_name: checkpoint field name\n        @type field_name: str\n\n        :return: formatted time value\n    '''\n    \n    try:\n        if check_digit(val):\n            helper.log_debug(f'Verifying time value format. {field_name} is: DIGIT')\n        elif check_datetime(val):\n            helper.log_debug(f'Verifying time value format. {field_name} is: DATETIME')\n            val = val.timestamp()\n        elif float(str(val)):\n            helper.log_debug(f'Verifying time value format. {field_name} is: FLOAT')\n            val = float(str(val))\n        else:\n            raise Exception(f'Unknown value type for time format.')\n    except Exception as e:\n        raise IOError(f'Invalid time format for checkpointing LastPass activity input. {field_name}=\"{val}\" type={type(val)} reason=\"{e.message}\"')\n\n    return str(val)\n    \n\ndef save_checkpoint(helper, time_curr, time_start, time_end):\n    ''' \n        update checkpoint with time value as epoch\n        @param time_curr: epoch time or datetime object\n        @type time_curr: datetime\n        @param time_start: epoch time or datetime object\n        @type time_start: datetime\n        @param time_end: epoch time or datetime object\n        @type time_end: datetime\n    '''\n\n    state_payload = {}\n\n    try:\n        state_payload[STR_TCURR] = prepare_time_value(helper, time_curr, STR_TCURR)\n        state_payload[STR_TSTART] = prepare_time_value(helper, time_start, STR_TSTART)\n        state_payload[STR_TEND] = prepare_time_value(helper, time_end, STR_TEND)\n\n        helper.log_debug(f'Saving checkpoint. state_payload={repr(state_payload)}')\n        helper.save_check_point(LP_CHECKPOINT_KEY, state_payload)\n    except Exception as e:\n        raise IOError(f'Save checkpoint failed. time_curr=\"{time_curr}\" time_start=\"{time_start}\" time_end=\"{time_end}\" reason=\"{e.message}\"')\n\n\ndef get_checkpoint(helper):\n    ''' \n        extract checkpoint payload, which includes time value\n        :return: epoch time or None\n    '''\n\n    # if checkpoint corrupted or not readable, consider empty\n    try:\n        state_payload = helper.get_check_point(LP_CHECKPOINT_KEY)\n    except Exception as e:\n        helper.log_warning(f'Loading checkpoint. Unable to load checkpoint. reason=\"{e.message}\"') \n        return None\n\n    # handle old checkpoint and just flush out other fields\n    if check_digit(state_payload) or check_float(state_payload):\n        helper.log_warning(f'Old checkpoint found. Pushing to new model with time start, end, and current values.')\n        return {STR_TCURR: None, STR_TSTART: state_payload, STR_TEND: None}\n\n    # validate if checkpoint payload of time values are formatted in float value for epoch\n    try:\n        helper.log_debug(f'checkpoint: type={type(state_payload)} value={repr(state_payload)}')\n        if not (state_payload.get(STR_TCURR) and prepare_time_value(helper, state_payload.get(STR_TCURR), STR_TCURR)):\n            raise Exception(f'valid time_curr field not found in checkpoint payload')\n        if not (state_payload[STR_TSTART] and prepare_time_value(helper, state_payload[STR_TSTART], STR_TSTART)):\n            raise Exception(f'valid time_start field not found in checkpoint payload')\n        if not (state_payload[STR_TEND] and prepare_time_value(helper, state_payload[STR_TEND], STR_TEND)):\n            raise Exception(f'valid time_end field not found in checkpoint payload')\n\n    except Exception as e:\n        helper.log_warning(f'Save checkpoint failed. time_curr=\\\"{state_payload.get(STR_TCURR)}\\\" time_start=\\\"{state_payload.get(STR_TSTART)}\\\" time_end=\\\"{state_payload.get(STR_TEND)}\\\" reason=\\\"{e}\\\"')\n        #raise Exception(f'Save checkpoint failed. time_curr=\\\"{state_payload.get(STR_TCURR)}\\\" time_start=\\\"{state_payload.get(STR_TSTART)}\\\" time_end=\\\"{state_payload.get(STR_TEND)}\\\" reason=\\\"{e}\\\"')\n        # return None\n        return None\n    \n\n    helper.log_debug(f'Extracted checkpoint time values. time_curr=\\\"{state_payload.get(STR_TCURR)}\\\" time_start=\\\"{state_payload.get(STR_TSTART)}\\\" time_end=\\\"{state_payload.get(STR_TEND)}\\\"')\n    return None\n\n\ndef get_time_dt(helper, time_val):\n    ''' evaluates time format and returns datetime. None if error.\n    @param time_val: timestamp value to check\n\n    @return time_dt: datetime or None\n    '''\n\n    if not time_val:\n        return None\n\n    try:\n        time_dt = None\n        if check_digit(time_val):\n            time_dt = datetime.datetime.fromtimestamp(int(time_val))\n        elif check_float(time_val):\n            time_dt = datetime.datetime.fromtimestamp(float(time_val))\n        else:\n            time_dt = datetime.datetime.strptime(str(time_val), LASTPASS_TIMEFORMAT)\n\n    except Exception as e:\n        helper.log_warning(f'Validating time format. Time conversion failed. time_val=\"{time_val}\" reason=\"{e}\"')\n        return None\n\n    diff = datetime.datetime.now() - time_dt\n    # check for within last 4y or if time is ahead\n    if diff.days > (365*4) or diff.days < 0:\n        helper.log_warning(f'Validating time format. out of range. time_val=\"{time_val}\"')\n        return None\n\n    return time_dt\n\n\ndef convert_time(time_val):\n    ''' convert time to datetime\n    @param time_val: epoch or YYYY-mm-dd HH:MM:SS format\n\n    @return datetime\n    '''\n    try:\n        if check_digit(time_val):\n            temp = datetime.datetime.fromtimestamp(int(time_val))\n        elif check_float(time_val):\n            temp = datetime.datetime.fromtimestamp(float(time_val))\n        else:\n            temp = datetime.datetime.strptime(str(time_val), LASTPASS_TIMEFORMAT)\n    except:\n        return None\n\n    return temp\n\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_global_account = helper.get_arg('global_account')\n    opt_lastpass_api_url = helper.get_arg('lastpass_api_url')\n    opt_time_start = helper.get_arg('time_start')\n    # In single instance mode, to get arguments of a particular input, use\n    opt_global_account = helper.get_arg('global_account', stanza_name)\n    opt_lastpass_api_url = helper.get_arg('lastpass_api_url', stanza_name)\n    opt_time_start = helper.get_arg('time_start', stanza_name)\n\n    # get input type\n    helper.get_input_type()\n\n    # The following examples get input stanzas.\n    # get all detailed input stanzas\n    helper.get_input_stanza()\n    # get specific input stanza with stanza name\n    helper.get_input_stanza(stanza_name)\n    # get all stanza names\n    helper.get_input_stanza_names()\n\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    account = helper.get_user_credential_by_username(\"username\")\n    account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    global_cid = helper.get_global_setting(\"cid\")\n    global_provhash = helper.get_global_setting(\"provhash\")\n\n    # The following examples show usage of logging related helper functions.\n    # write to the log for this modular input using configured global log level or INFO as default\n    helper.log(\"log message\")\n    # write to the log using specified log level\n    helper.log_debug(\"log message\")\n    helper.log_info(\"log message\")\n    helper.log_warning(\"log message\")\n    helper.log_error(\"log message\")\n    helper.log_critical(\"log message\")\n    # set the log level for this modular input\n    # (log_level can be \"debug\", \"info\", \"warning\", \"error\" or \"critical\", case insensitive)\n    helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(url, method, parameters=None, payload=None,\n                                        headers=None, cookies=None, verify=True, cert=None,\n                                        timeout=None, use_proxy=True)\n    # get the response headers\n    r_headers = response.headers\n    # get the response body as text\n    r_text = response.text\n    # get response body as json. If the body text is not a json string, raise a ValueError\n    r_json = response.json()\n    # get response cookies\n    r_cookies = response.cookies\n    # get redirect history\n    historical_responses = response.history\n    # get response status code\n    r_status = response.status_code\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n    # The following examples show usage of check pointing related helper functions.\n    # save checkpoint\n    helper.save_check_point(key, state)\n    # delete checkpoint\n    helper.delete_check_point(key)\n    # get checkpoint\n    state = helper.get_check_point(key)\n\n    # To create a splunk event\n    helper.new_event(data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    \"\"\"\n\n    '''\n    # The following example writes a random number as an event. (Multi Instance Mode)\n    # Use this code template by default.\n    import random\n    data = str(random.randint(0,100))\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n    ew.write_event(event)\n    '''\n\n    '''\n    # The following example writes a random number as an event for each input config. (Single Instance Mode)\n    # For advanced users, if you want to create single instance mod input, please use this code template.\n    # Also, you need to uncomment use_single_instance_mode() above.\n    import random\n    input_type = helper.get_input_type()\n    for stanza_name in helper.get_input_stanza_names():\n        data = str(random.randint(0,100))\n        event = helper.new_event(source=input_type, index=helper.get_output_index(stanza_name), sourcetype=helper.get_sourcetype(stanza_name), data=data)\n        ew.write_event(event)\n    '''\n\n    rest_url = helper.get_arg('lastpass_api_url')\n\n    if not rest_url:\n        rest_url = 'https://lastpass.com/enterpriseapi.php'\n    # pre-fix domain to proper URL\n    elif 'https://' not in rest_url:\n        rest_url = f'https://{rest_url}'\n\n    # expected time format: epoch\n    payload_checkpoint = get_checkpoint(helper)\n\n    # expected time format: datetime\n    time_start = get_time_dt(helper, helper.get_global_setting(STR_TSTART))\n    time_now = datetime.datetime.now()\n    \n    helper.log_debug(f'LastPass parameter check: rest_url={rest_url} time_checkpoint={repr(payload_checkpoint)} time_start=\"{time_start}\"')\n    headers = {}\n\n    # build data params\n    data = {}\n    data['data'] = {}\n    data['cid'] = helper.get_global_setting('cid')\n    data['provhash'] = helper.get_global_setting('provhash')\n    data['cmd'] = CMD_REPORTING\n    data['apiuser'] = 'splunk.collector'\n    data['user'] = 'allusers'\n\n    ''' algorithm w checkpointing:\n        no time input and no chk time => last 24h\n        no time input and chk time exists => chk time\n        time input and no chk time => time input\n        time input and chk time both = 1 => chk time\n    '''\n\n    time_default = (time_now - datetime.timedelta(days=1)).replace(microsecond=0)\n\n    if not time_start and not payload_checkpoint:\n        helper.log_debug(f'time_start check: not time_start and not payload_checkpoint')\n        # set earliest time for collection = -24h\n        time_start = time_default\n\n    elif not time_start and payload_checkpoint:\n        time_start = get_time_dt(helper, payload_checkpoint)\n        helper.log_debug(f'time_start check: not time_start and payload_checkpoint')\n\n    elif time_start and not payload_checkpoint:\n        helper.log_debug(f'time_start check: time_start and not payload_checkpoint')\n        # use specified time input\n        pass\n\n    elif (time_start and payload_checkpoint) and (payload_checkpoint - time_start) > 0:\n        helper.log_debug(f'time_start check: (time_start and payload_checkpoint) and (payload_checkpoint - time_start) > 0')\n        time_start = get_time_dt(helper, payload_checkpoint.get(STR_TSTART))\n\n    else:\n        time_start = time_default\n\n    # increase interval in case backfill is extensive\n    diff = time_now - time_start\n    # increase increment for pull by date if a large range\n    day_incr = 1 if diff.days < 7 else 3\n\n    if day_incr > 1:\n        helper.log_info(f'LastPass event report collection. large date range. start=\"{time_start}\"\\tend=\"{time_now}\"')\n\n    for i in range(0, diff.days+1, day_incr):\n        start = time_start + datetime.timedelta(days=i)\n        end = start + datetime.timedelta(days=day_incr) - datetime.timedelta(seconds=1)\n        end = time_now if time_now < end else end\n        event_time = None\n\n        # update query dates\n        data['data']['from'] = get_time_lp(start)\n        data['data']['to'] = get_time_lp(end)\n\n        helper.log_debug(f'LastPass event report collection. Tracking event pulling: time_start=\\\"{data[\"data\"][\"from\"]}\\\" time_end=\\\"{data[\"data\"][\"to\"]}\\\"')\n\n        try:\n            resp_ev = requests.post(rest_url, headers=headers, data=json.dumps(data))\n            \n            if resp_ev.status_code != 200:\n                helper.log_exception(f'LastPass event report collection. request data failed.')                \n            elif re.search(r\"(Authorization Error)\", resp_ev.text):\n                helper.log_exception(f'LastPass event report collection. request data failed. 401: Unauthorized. Verify cid/provhash.')\n\n            resp_ev_json = resp_ev.json()\n\n            if 'OK' not in resp_ev_json['status']:\n                helper.log_error(f'LastPass event report collection. REST call successful, but query is bad. Validate request params. Terminating script')\n                sys.exit(1)\n            \n            chk_ptr = 0\n\n            # WARNING: data is returned most recent or latest (Event1) to oldest or earliest (Event<Max>)\n            for ev_id in resp_ev_json['data']:\n\n                ev_payload = copy.deepcopy(resp_ev_json['data'][ev_id])\n\n                # add additional fields for better event data quality\n                ev_payload['event_id'] = ev_id\n\n                # capture event time from lp event\n                event_time = convert_time(ev_payload['Time'])\n\n                # if no proper timestamp extracted from event, default to current\n                # if timestamp has milliseconds, then extraction unsuccessful as lastpass limited to seconds\n                if not event_time:\n                    event_time = datetime.datetime.now().timestamp()\n                else:\n                    event_time = event_time.strftime('%s.%f')\n\n                ev_payload['time_collected'] = datetime.datetime.now().timestamp()\n\n                event = helper.new_event(data=json.dumps(ev_payload), time=event_time, source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype())\n                ew.write_event(event)\n\n                # checkpoint timestamp every 1000 messages\n                chk_ptr += 1\n                if chk_ptr % 1000 == 0:\n                    save_checkpoint(helper, event_time, time_start, time_now)\n                    helper.log_debug(f'LastPass event report collection. Updating checkpoint to date: time_start=\\\"{data[\"data\"][\"from\"]}\\\" time_end=\\\"{data[\"data\"][\"to\"]}\\\" curr_time={event_time}')\n\n            # checkpoint finally when done\n            if event_time:\n                save_checkpoint(helper, event_time, time_start, time_now)\n                helper.log_debug(f'LastPass event report collection. Updating checkpoint to date: time_start=\\\"{data[\"data\"][\"from\"]}\\\" time_end=\\\"{data[\"data\"][\"to\"]}\\\" curr_time={event_time}')\n\n        except Exception as e:\n            helper.log_critical(f'LastPass event report collection. Error in forwarding data: {traceback.format_exc()}')\n            raise e                \n", "customized_options": [{"name": "lastpass_api_url", "value": "https://lastpass.com/enterpriseapi.php"}, {"name": "time_start", "value": "2020-06-01 00:00:00"}], "uuid": "d921465fd5f245bca3f3c3f7828ef42a", "sample_count": "382371"}]}, "field_extraction_builder": {"lastpass:activity": {"is_parsed": true, "data_format": "json"}, "lastpass:folders": {"is_parsed": true, "data_format": "json"}, "lastpass:groups": {"is_parsed": true, "data_format": "json"}, "lastpass:users": {"is_parsed": true, "data_format": "json"}, "ta:lastpass:log": {"data_format": "unstructured_data"}}, "global_settings_builder": {"global_settings": {"log_settings": {"log_level": "DEBUG"}, "customized_settings": [{"required": true, "name": "cid", "label": "Customer id", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "7857555"}, {"required": true, "name": "provhash", "label": "Provisioning Hash", "placeholder": "", "default_value": "", "help_string": "API access token", "type": "password", "format_type": "password", "value": ""}]}}, "sourcetype_builder": {"lastpass:activity": {"metadata": {"event_count": 0, "data_input_name": "lastpass_event_reporting", "extractions_count": 0, "cims_count": 0}}, "lastpass:users": {"metadata": {"event_count": 0, "data_input_name": "lastpass_users", "extractions_count": 0, "cims_count": 0}}, "lastpass:folders": {"metadata": {"event_count": 0, "data_input_name": "lastpass_shared_folders", "extractions_count": 0, "cims_count": 0}}, "lastpass:groups": {"metadata": {"event_count": 0, "data_input_name": null, "extractions_count": 0, "cims_count": 0}}, "test": {"metadata": {"event_count": 0, "data_input_name": null, "extractions_count": 0, "cims_count": 0}}}, "validation": {}}